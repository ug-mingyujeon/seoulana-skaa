<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>사이버펑크 탑다운 슈터 v2.1</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* CSS는 이전과 동일 */
        body { margin: 0; overflow: hidden; background-color: #000; display: flex; justify-content: center; align-items: center; min-height: 100vh; font-family: 'Press Start 2P', cursive; color: #fff; text-align: center; }
        #game-container { position: relative; width: 800px; height: 600px; border-radius: 10px; overflow: hidden; box-shadow: 0 0 15px 5px rgba(0, 255, 255, 0.6), 0 0 5px 1px rgba(255, 0, 255, 0.5) inset; cursor: crosshair; border: 1px solid rgba(0, 255, 255, 0.3); }
        canvas { display: block; width: 100%; height: 100%; background-color: #050510; }
        #ui-container { position: absolute; top: 15px; left: 15px; right: 15px; display: flex; justify-content: space-between; align-items: flex-start; pointer-events: none; font-size: 18px; }
        #score-info { text-align: left; text-shadow: 0 0 5px #0f0; }
        #upgrade-info { text-align: right; text-shadow: 0 0 5px #ff0; }
        #score { color: #0f0; font-size: 22px; margin-bottom: 5px; }
        #high-score { color: #f90; font-size: 16px; margin-bottom: 5px; text-shadow: 0 0 5px #f90; }
        #upgrade-points, #next-upgrade-progress { color: #ff0; margin-bottom: 5px; font-size: 16px; }
        #dash-status { position: absolute; bottom: 15px; left: 15px; font-size: 14px; color: #0ff; text-shadow: 0 0 5px #0ff; }
        #upgrade-message { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 18px; color: #f0f; text-shadow: 0 0 7px #f0f; opacity: 0; transition: opacity 0.5s ease-out; pointer-events: none; }
        #upgrade-choice-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); display: none; justify-content: center; align-items: center; z-index: 10; pointer-events: auto; }
        #upgrade-choice-container { background-color: rgba(10, 10, 20, 0.95); padding: 30px 40px; border-radius: 10px; border: 2px solid #f0f; box-shadow: 0 0 25px #f0f; text-align: center; }
        #upgrade-choice-container h3 { margin: 0 0 10px 0; font-size: 24px; color: #f0f; text-shadow: 0 0 5px #f0f; }
        #upgrade-choice-container p { font-size: 12px; color: #aaa; margin-bottom: 25px; }
        .upgrade-button-container { display: flex; justify-content: center; gap: 10px; flex-wrap: wrap; }
        .upgrade-option { display: flex; flex-direction: column; align-items: center; margin-bottom: 10px; }
        .upgrade-button { font-family: 'Press Start 2P', cursive; font-size: 13px; padding: 8px 12px; margin: 0; border: 1px solid rgba(255, 255, 255, 0.5); border-radius: 8px; cursor: pointer; transition: transform 0.1s ease, box-shadow 0.1s ease, filter 0.1s ease, background-color 0.1s ease; color: #fff; text-shadow: 0 0 3px #000; min-width: 110px; background-color: rgba(50, 50, 50, 0.7); }
        .upgrade-button-label { font-size: 10px; color: #ccc; margin-top: 5px; }
        #upgrade-firerate { border-color: #ff4500; } #upgrade-firerate:hover { background-color: #ff4500; box-shadow: 0 0 15px #ff4500; }
        #upgrade-damage { border-color: #ff416c; } #upgrade-damage:hover { background-color: #ff416c; box-shadow: 0 0 15px #ff416c; }
        #upgrade-spread { border-color: #8a2be2; } #upgrade-spread:hover { background-color: #8a2be2; box-shadow: 0 0 15px #8a2be2; }
        #upgrade-dash { border-color: #2193b0; } #upgrade-dash:hover { background-color: #2193b0; box-shadow: 0 0 15px #2193b0; }
        .upgrade-button:active { transform: scale(0.95); filter: brightness(0.8); }
        #message-box { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(10, 0, 10, 0.9); padding: 45px; border-radius: 15px; display: none; flex-direction: column; align-items: center; pointer-events: auto; border: 3px solid #f0f; box-shadow: 0 0 25px #f0f; z-index: 10; }
        #message-box h2 { margin: 0 0 20px 0; color: #f00; text-shadow: 0 0 7px #f00; font-size: 36px; }
        #message-box p { margin: 0 0 30px 0; font-size: 20px; color: #eee; }
        #new-highscore-message { color: #ff0; font-size: 22px; margin-bottom: 15px; display: none; text-shadow: 0 0 5px #ff0; }
        #restart-button { font-family: 'Press Start 2P', cursive; font-size: 22px; padding: 15px 30px; background: linear-gradient(45deg, #f0f, #0ff); color: #fff; border: none; border-radius: 12px; cursor: pointer; transition: transform 0.1s ease, box-shadow 0.1s ease; box-shadow: 0 6px 12px rgba(255, 0, 255, 0.5); text-shadow: 0 0 5px #000; }
        #restart-button:hover { transform: scale(1.05); box-shadow: 0 8px 16px rgba(255, 0, 255, 0.7); }
        #restart-button:active { transform: scale(0.95); }
        
        /* 난이도 선택 오버레이 스타일 */
        #difficulty-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 20;
            pointer-events: auto;
        }
        
        #difficulty-container {
            background-color: rgba(10, 10, 20, 0.95);
            padding: 30px 40px;
            border-radius: 10px;
            border: 2px solid #f0f;
            box-shadow: 0 0 25px #f0f;
            text-align: center;
        }
        
        #difficulty-container h3 {
            margin: 0 0 20px 0;
            font-size: 24px;
            color: #f0f;
            text-shadow: 0 0 5px #f0f;
        }
        
        #difficulty-container p {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 25px;
        }
        
        .difficulty-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .difficulty-button {
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            padding: 12px 20px;
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.1s ease, box-shadow 0.1s ease;
            color: #fff;
            text-shadow: 0 0 3px #000;
            min-width: 120px;
        }
        
        #easy-button {
            border-color: #00ff00;
            background-color: rgba(0, 100, 0, 0.7);
        }
        
        #easy-button:hover {
            background-color: #00ff00;
            box-shadow: 0 0 15px #00ff00;
        }
        
        #normal-button {
            border-color: #ffff00;
            background-color: rgba(100, 100, 0, 0.7);
        }
        
        #normal-button:hover {
            background-color: #ffff00;
            box-shadow: 0 0 15px #ffff00;
        }
        
        #hard-button {
            border-color: #ff0000;
            background-color: rgba(100, 0, 0, 0.7);
        }
        
        #hard-button:hover {
            background-color: #ff0000;
            box-shadow: 0 0 15px #ff0000;
        }
        
        .difficulty-button:active {
            transform: scale(0.95);
        }
        
        #difficulty-value {
            position: absolute;
            top: 15px;
            right: 15px;
            color: #0ff;
            font-size: 14px;
            text-shadow: 0 0 5px #0ff;
        }

        /* 솔라나 월렛 버튼 */
        #wallet-button {
            position: absolute;
            top: 15px;
            right: 120px;
            color: #fff;
            font-size: 12px;
            text-shadow: 0 0 5px #f0f;
            border: 1px solid #f0f;
            background-color: rgba(50, 0, 50, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            pointer-events: auto;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 0, 255, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 0, 255, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 255, 0); }
        }
        
        #minted-tokens {
            position: absolute;
            top: 40px;
            right: 15px;
            color: #f0f;
            font-size: 10px;
            text-shadow: 0 0 3px #f0f;
        }
        
        #mint-status {
            position: absolute;
            bottom: 20px;
            right: 15px;
            font-size: 12px;
            color: #f0f;
            text-shadow: 0 0 5px #f0f;
        }
        
        #wallet-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 30;
            pointer-events: auto;
        }
        
        #wallet-container {
            background-color: rgba(10, 10, 20, 0.95);
            padding: 30px 40px;
            border-radius: 10px;
            border: 2px solid #f0f;
            box-shadow: 0 0 25px #f0f;
            text-align: center;
        }
        
        #mint-progress {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background-color: rgba(255, 0, 255, 0.3);
        }
        
        #mint-progress-bar {
            height: 100%;
            width: 0%;
            background-color: #f0f;
            transition: width 0.3s ease;
        }

        #connect-wallet-button {
            margin-bottom: 10px;
            background-color: rgba(140, 0, 140, 0.7);
            border-color: #f0f;
        }
        
        #connect-wallet-button:hover {
            background-color: #f0f;
            box-shadow: 0 0 15px #f0f;
        }
        
        #connect-solflare-button {
            background-color: rgba(25, 95, 255, 0.7);
            border-color: #1962ff;
        }
        
        #connect-solflare-button:hover {
            background-color: #1962ff;
            box-shadow: 0 0 15px #1962ff;
        }
        
        #connect-test-button {
            background-color: rgba(0, 200, 0, 0.7);
            border-color: #00cc00;
            margin-top: 10px;
        }
        
        #connect-test-button:hover {
            background-color: #00cc00;
            box-shadow: 0 0 15px #00cc00;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="ui-container">
            <div id="score-info">
                <div id="score">Score: 0</div>
                <div id="high-score">High: 0</div>
            </div>
            <div id="upgrade-info">
                 <div id="upgrade-points">Points: 0</div>
                 <div id="next-upgrade-progress">Next: 200pts</div>
            </div>
        </div>
         <div id="dash-status">Dash: READY</div>
         <div id="upgrade-message"></div>
         <div id="upgrade-choice-overlay">
             <div id="upgrade-choice-container">
                 <h3>Choose Upgrade (1 Point)</h3>
                 <p>Enhance your cybernetics.</p>
                 <div class="upgrade-button-container">
                     <div class="upgrade-option">
                         <button id="upgrade-firerate" class="upgrade-button">Fire Rate+</button>
                         <span id="firerate-label" class="upgrade-button-label">Cooldown: 20</span>
                     </div>
                     <div class="upgrade-option">
                         <button id="upgrade-damage" class="upgrade-button">Damage+</button>
                         <span id="damage-label" class="upgrade-button-label">Damage: 1.0</span>
                     </div>
                      <div class="upgrade-option">
                         <button id="upgrade-spread" class="upgrade-button">Spread+</button>
                         <span id="spread-label" class="upgrade-button-label">Bullets: 1</span>
                     </div>
                      <div class="upgrade-option">
                         <button id="upgrade-dash" class="upgrade-button">Dash CD-</button>
                         <span id="dash-label" class="upgrade-button-label">Cooldown: 2.0s</span>
                     </div>
                 </div>
             </div>
         </div>
        <div id="message-box">
            <h2>SYSTEM OFFLINE</h2>
            <p id="new-highscore-message">New High Score Archived!</p>
            <p id="final-score">Job Score: 0</p>
            <button id="restart-button">Reboot System</button>
        </div>
        
        <!-- 난이도 선택 오버레이 -->
        <div id="difficulty-overlay">
            <div id="difficulty-container">
                <h3>난이도 선택</h3>
                <p>적의 스폰 확률, 속도, 체력이 변경됩니다.<br>대시 시 짧은 시간 동안 무적 상태가 됩니다!</p>
                <div class="difficulty-buttons">
                    <button id="easy-button" class="difficulty-button">쉬움</button>
                    <button id="normal-button" class="difficulty-button">보통</button>
                    <button id="hard-button" class="difficulty-button">어려움</button>
                </div>
            </div>
        </div>
        
        <!-- 현재 난이도 표시 -->
        <div id="difficulty-value">난이도: 쉬움</div>
        
        <!-- 솔라나 월렛 버튼 -->
        <button id="wallet-button">지갑 연결</button>
        <div id="minted-tokens">민팅된 토큰: 0</div>
        <div id="mint-status"></div>
        
        <!-- 민팅 진행 바 -->
        <div id="mint-progress">
            <div id="mint-progress-bar"></div>
        </div>
        
        <!-- 솔라나 월렛 오버레이 -->
        <div id="wallet-overlay">
            <div id="wallet-container">
                <h3>솔라나 지갑 연결 필요</h3>
                <p>게임 토큰을 민팅하려면 솔라나 지갑을 연결해주세요.</p>
                <div id="wallet-buttons-container" style="display: flex; flex-direction: column; gap: 10px; margin-top: 15px;">
                    <button id="connect-wallet-button" class="difficulty-button">팬텀 지갑 연결</button>
                    <button id="connect-solflare-button" class="difficulty-button">솔플레어 지갑 연결</button>
                    <button id="connect-slope-button" class="difficulty-button">슬로프 지갑 연결</button>
                    <button id="wallet-adapter-button" class="difficulty-button" style="background-color: rgba(50, 100, 255, 0.7); border-color: #3264ff;">모든 지갑 보기</button>
                    <button id="connect-custom-button" class="difficulty-button" style="background-color: rgba(220, 60, 40, 0.7); border-color: #dc3c28;">SKAA 지갑</button>
                    <button id="connect-test-button" class="difficulty-button">테스트 모드로 진행</button>
                </div>
                <p id="wallet-error-message" style="color: #ff0000; font-size: 12px; margin-top: 10px;"></p>
            </div>
        </div>
    </div>

    <!-- 솔라나 웹3, 지갑 관련 라이브러리 -->
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@solana/spl-token@0.3.8/lib/index.iife.min.js"></script>
    
    <!-- 솔라나 월렛 어댑터 추가 -->
    <script src="https://unpkg.com/@solana/wallet-adapter-base@latest/lib/index.iife.js"></script>
    <script src="https://unpkg.com/@solana/wallet-adapter-wallets@latest/lib/index.iife.js"></script>
    
    <!-- 특정 지갑 어댑터 -->
    <script src="https://unpkg.com/@solflare-wallet/sdk@1.1.1/dist/solflare-sdk.min.js"></script>
    <script src="https://unpkg.com/@project-serum/sol-wallet-adapter@latest/dist/index.iife.js"></script>

    <!-- 서명 팝업 오버레이 (테스트 모드용) -->
    <div id="signature-overlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); display: none; justify-content: center; align-items: center; z-index: 40; pointer-events: auto;">
        <div style="background-color: rgba(10, 10, 20, 0.95); padding: 30px 40px; border-radius: 10px; border: 2px solid #f0f; box-shadow: 0 0 25px #f0f; text-align: center; max-width: 400px;">
            <h3 style="margin: 0 0 20px 0; font-size: 24px; color: #f0f; text-shadow: 0 0 5px #f0f;">트랜잭션 서명 필요</h3>
            <p style="font-size: 14px; color: #fff; margin-bottom: 15px;">테스트 트랜잭션을 서명하시겠습니까?</p>
            <p style="font-size: 12px; color: #aaa; margin-bottom: 25px; word-break: break-all;">트랜잭션: TEST-TX-1234567890-ABCDEF</p>
            <div style="display: flex; justify-content: space-between; gap: 20px;">
                <button id="sign-approve-button" class="difficulty-button" style="background-color: rgba(0, 200, 0, 0.7); border-color: #00cc00;">승인</button>
                <button id="sign-reject-button" class="difficulty-button" style="background-color: rgba(200, 0, 0, 0.7); border-color: #cc0000;">거부</button>
            </div>
        </div>
    </div>

    <script>
        // --- 요소 가져오기 (이전과 동일) ---
        const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container'); const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('high-score'); const upgradePointsElement = document.getElementById('upgrade-points');
        const nextUpgradeProgressElement = document.getElementById('next-upgrade-progress'); const dashStatusElement = document.getElementById('dash-status');
        const upgradeMessageElement = document.getElementById('upgrade-message'); const upgradeChoiceOverlay = document.getElementById('upgrade-choice-overlay');
        const upgradeFirerateButton = document.getElementById('upgrade-firerate'); const upgradeDamageButton = document.getElementById('upgrade-damage');
        const upgradeSpreadButton = document.getElementById('upgrade-spread'); const upgradeDashButton = document.getElementById('upgrade-dash');
        const firerateLabel = document.getElementById('firerate-label'); const damageLabel = document.getElementById('damage-label');
        const spreadLabel = document.getElementById('spread-label'); const dashLabel = document.getElementById('dash-label');
        const messageBox = document.getElementById('message-box'); const finalScoreElement = document.getElementById('final-score');
        const newHighScoreMessageElement = document.getElementById('new-highscore-message'); const restartButton = document.getElementById('restart-button');
        
        // 난이도 선택 요소 가져오기
        const difficultyOverlay = document.getElementById('difficulty-overlay');
        const easyButton = document.getElementById('easy-button');
        const normalButton = document.getElementById('normal-button');
        const hardButton = document.getElementById('hard-button');
        const difficultyValueElement = document.getElementById('difficulty-value');
        
        // 솔라나 관련 요소 가져오기
        const walletButton = document.getElementById('wallet-button');
        const mintedTokensElement = document.getElementById('minted-tokens');
        const mintStatusElement = document.getElementById('mint-status');
        const mintProgressBar = document.getElementById('mint-progress-bar');
        const walletOverlay = document.getElementById('wallet-overlay');
        const connectWalletButton = document.getElementById('connect-wallet-button');
        const connectSolflareButton = document.getElementById('connect-solflare-button');
        const connectTestButton = document.getElementById('connect-test-button');
        const walletErrorMessage = document.getElementById('wallet-error-message');
        
        // 추가된 월렛 어댑터 관련 요소
        const connectSlopeButton = document.getElementById('connect-slope-button');
        const walletAdapterButton = document.getElementById('wallet-adapter-button');
        
        // 서명 팝업 관련 요소
        const signatureOverlay = document.getElementById('signature-overlay');
        const signApproveButton = document.getElementById('sign-approve-button');
        const signRejectButton = document.getElementById('sign-reject-button');
        
        // 서명 프로미스 (테스트 모드용)
        let signatureResolve = null;
        let signatureReject = null;
        
        // 지원되는 지갑 목록과 어댑터 객체 저장
        let walletAdapters = [];
        let availableWallets = [];
        let walletProviders = {};

        // 커스텀 지갑 관련 변수
        let customWalletWindow = null;
        
        // 커스텀 지갑 연결 함수
        async function connectCustomWallet() {
            console.log("커스텀 지갑 연결 시도 (구글 로그인)...");
            walletErrorMessage.textContent = "";
            
            try {
                // 팝업 창 열기
                const width = 500;
                const height = 600;
                const left = window.screenX + (window.outerWidth - width) / 2;
                const top = window.screenY + (window.outerHeight - height) / 2;
                
                const features = `width=${width},height=${height},left=${left},top=${top},resizable=yes,scrollbars=yes,status=yes`;
                customWalletWindow = window.open('http://localhost:3000/auth/google', 'googleLogin_' + Date.now(), features);
                
                if (!customWalletWindow) {
                    throw new Error('팝업 창이 차단되었습니다. 팝업 차단을 해제해주세요.');
                }
                
                // 로그인 진행 중 메시지 표시
                showMintStatus("구글 로그인 진행 중...", "yellow");
                
                // 메시지 이벤트 리스너 등록
                window.addEventListener('message', handleCustomWalletMessage);
                
            } catch (err) {
                console.error("커스텀 지갑 연결 오류:", err);
                walletErrorMessage.textContent = err.message || "지갑 연결에 실패했습니다.";
                showMintStatus("지갑 연결 실패", "red");
            }
        }
        
        // 커스텀 지갑 메시지 처리 함수
        function handleCustomWalletMessage(event) {
            console.log("메시지 수신:", event.origin, event.data);
            
            // localhost:9000에서 온 메시지만 처리
            if (event.origin !== 'http://localhost:3000') {
                return;
            }
            
            // 이벤트 리스너 제거
            window.removeEventListener('message', handleCustomWalletMessage);
            
            if (true) {
                // 인증 성공 처리
                const { publicKey, token, user } = event.data;
                
                // 사용자 정보 로깅
                console.log("인증된 사용자:", user.name, user.email);
                
                // 커스텀 지갑 객체 생성
                const customWallet = {
                    publicKey: {
                        toString: () => publicKey,
                        toBase58: () => publicKey
                    },
                    signTransaction: async (tx) => {
                        console.log("커스텀 지갑: 트랜잭션 서명 요청");
                        
                        // 서명 테스트 표시
                        showMintStatus("트랜잭션 서명 중...", "yellow");
                        
                        // 실제 게임에서는 서버로 서명 요청을 보내야 함
                        // 이 예제에서는, 서명이 성공했다고 가정
                        return { signedTransaction: tx };
                    },
                    signAllTransactions: async (txs) => {
                        console.log("커스텀 지갑: 다중 트랜잭션 서명 요청");
                        
                        // 서명 테스트 표시
                        showMintStatus("다중 트랜잭션 서명 중...", "yellow");
                        
                        // 실제 게임에서는 서버로 서명 요청을 보내야 함
                        // 이 예제에서는, 서명이 성공했다고 가정
                        return txs.map(tx => ({ signedTransaction: tx }));
                    },
                    connected: true,
                    isConnected: true,
                    userInfo: {
                        name: user.name,
                        email: user.email,
                        id: user.id
                    }
                };
                
                // 지갑 연결 설정
                wallet = customWallet;
                walletConnected = true;
                currentWalletType = 'custom';
                walletButton.textContent = publicKey.substr(0, 4) + "..." + publicKey.substr(-4);
                walletOverlay.style.display = 'none';
                connection = new solanaWeb3.Connection("https://api.devnet.solana.com");
                
                // 성공 메시지 표시
                showMintStatus("구글 로그인을 통한 지갑 연결 완료!", "green");
                
                console.log("커스텀 지갑 연결 완료:", publicKey);
                
                // 쿠키 확인
                checkForEmailCookie();
            } else {
                // 인증 실패 처리
                console.error("Google 인증 실패:", event.data?.error || "Unknown error");
                walletErrorMessage.textContent = "Google 인증에 실패했습니다.";
                showMintStatus("인증 실패", "red");
            }
        }
        
        // 이메일 쿠키 확인 함수
        function checkForEmailCookie() {
            // game_user_email 쿠키 찾기
            const cookies = document.cookie.split(';');
            let emailCookie = null;
            
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.startsWith('game_user_email=')) {
                    emailCookie = cookie.substring('game_user_email='.length, cookie.length);
                    break;
                }
            }
            
            if (emailCookie) {
                console.log("쿠키에서 이메일 발견:", decodeURIComponent(emailCookie));
                
                // 월렛 버튼에 이메일 표시 (선택사항)
                if (wallet && wallet.userInfo) {
                    walletButton.title = `연결된 이메일: ${decodeURIComponent(emailCookie)}`;
                }
                
                // 쿠키 확인 메시지 표시
                showMintStatus("이메일 쿠키 확인됨!", "green");
            } else {
                console.log("이메일 쿠키를 찾을 수 없음");
            }
        }
        
        // 이메일 쿠키 유효성 확인 함수
        function checkEmailCookieValid() {
            // game_user_email 쿠키 찾기
            const cookies = document.cookie.split(';');
            let emailCookie = null;
            
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.startsWith('game_user_email=')) {
                    emailCookie = cookie.substring('game_user_email='.length, cookie.length);
                    break;
                }
            }
            
            // 쿠키가 존재하고, 값이 있는지 확인
            if (emailCookie && emailCookie.length > 0) {
                const email = decodeURIComponent(emailCookie);
                
                // 이메일 형식 검증 (간단한 정규식)
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                if (emailRegex.test(email)) {
                    return true;
                }
            }
            
            return false;
        }

        // --- 게임 변수 (이전과 동일) ---
        let player; let bullets = []; let enemies = []; let enemyBullets = []; let particles = []; let pickups = []; let gridLines = [];
        let score = 0; let highScore = 0; let gameOver = false; let isPaused = false; let gameLoopId; let keys = {};
        let mousePos = { x: 0, y: 0 }; let enemySpawnTimer = 0; let baseEnemySpawnInterval = 120; let currentEnemySpawnInterval = baseEnemySpawnInterval;
        let minEnemySpawnInterval = 40; let difficultyIncreaseFactor = 0.03; let difficultyMultiplier = 1.0;
        let upgradeMessageTimeout; let screenShakeIntensity = 0; let screenShakeDuration = 0;
        const scoreThresholds = [200, 500, 1000, 2000, 4000, 7000, 10000]; let currentUpgradeLevel = 0;
        const SHOOTER_ENEMY_SCORE_THRESHOLD = 1500;
        
        // 솔라나 관련 변수
        let mintedTokens = 0;
        let walletConnected = false;
        let mintCooldown = false;
        let mintCooldownTimer = 0;
        let wallet = null;
        let mintPending = false;
        let connection = null;
        let currentWalletType = null; // 'phantom' 또는 'solflare'
        
        // 민팅 확률 조정 (난이도에 따라 조정)
        const MINT_CHANCE = 1.0; // 100% 확률로 민팅 시도
        const MINT_COOLDOWN = 60; // 1초 쿨다운 (60프레임)
        
        // 난이도 관련 변수 추가
        let currentDifficulty = 'easy'; // 기본값은 쉬움
        let difficultyMultipliers = {
            easy: {
                enemyHealth: 1.0,
                enemySpeed: 1.0,
                enemySpawn: 1.0,
                enemyDamage: 1.0,
                scoreMultiplier: 1.0
            },
            normal: {
                enemyHealth: 1.3,
                enemySpeed: 1.2,
                enemySpawn: 1.2,
                enemyDamage: 1.2,
                scoreMultiplier: 1.3
            },
            hard: {
                enemyHealth: 1.4,
                enemySpeed: 1.3,
                enemySpawn: 1.4,
                enemyDamage: 1.3,
                scoreMultiplier: 1.7
            }
        };

        // --- 색상 정의 (이전과 동일) ---
        const playerColor = '#00ffff'; const playerGlow = 'rgba(0, 255, 255, 0.7)';
        const bulletColor = '#f0ffff'; const bulletGlow = 'rgba(0, 255, 255, 0.8)';
        const enemyNormalColor = '#4444ff'; const enemyNormalGlow = 'rgba(100, 100, 255, 0.6)';
        const enemyFastColor = '#ff4500'; const enemyFastGlow = 'rgba(255, 69, 0, 0.6)';
        const enemyShooterColor = '#ff00ff'; const enemyShooterGlow = 'rgba(255, 0, 255, 0.6)';
        const enemyBulletColor = '#ff1493'; const pickupColor = '#00ff00'; const pickupGlow = 'rgba(0, 255, 0, 0.7)';
        const gridColor = 'rgba(0, 150, 255, 0.2)';
        
        const gridSpacing = 50; const gridScrollSpeed = 0.3; let gridOffsetY = 0;
        function drawBackground(){
            ctx.fillStyle='#050510';
            ctx.fillRect(0,0,canvas.width,canvas.height);
            gridOffsetY=(gridOffsetY+gridScrollSpeed)%gridSpacing;
            ctx.strokeStyle=gridColor;
            ctx.lineWidth=1;
            ctx.shadowColor='rgba(0,200,255,0.5)';
            ctx.shadowBlur=5;
            for(let y=gridOffsetY;y<canvas.height;y+=gridSpacing){
                const pF=y/canvas.height;
                ctx.globalAlpha=0.1+pF*0.4;
                ctx.beginPath();
                ctx.moveTo(0,y);
                ctx.lineTo(canvas.width,y);
                ctx.stroke();
            }
            for(let x=0;x<canvas.width;x+=gridSpacing){
                ctx.globalAlpha=0.3;
                ctx.beginPath();
                ctx.moveTo(x,0);
                ctx.lineTo(x,canvas.height);
                ctx.stroke();
            }
            ctx.globalAlpha=1.0;
            ctx.shadowBlur=0;
        }

        // 솔라나 관련 함수
        async function connectPhantomWallet() {
            console.log("팬텀 지갑 연결 시도...");
            walletErrorMessage.textContent = "";
            
            try {
                // 브라우저에 Phantom 지갑이 설치되어 있는지 확인
                const isPhantomInstalled = window.phantom?.solana?.isPhantom || window.solana?.isPhantom;
                
                if (!isPhantomInstalled) {
                    console.log("팬텀 지갑이 설치되지 않음");
                    walletErrorMessage.textContent = "팬텀 지갑이 설치되어 있지 않습니다. 설치 후 다시 시도해주세요.";
                    return;
                }
                
                console.log("팬텀 지갑 감지됨, 연결 시도 중...");
                
                try {
                    // 지갑 인스턴스 가져오기
                    const provider = window.phantom?.solana || window.solana;
                    
                    // 연결 요청
                    const resp = await provider.connect();
                    console.log("연결 성공:", resp.publicKey.toString());
                    
                    wallet = provider;
                    walletConnected = true;
                    currentWalletType = 'phantom';
                    walletButton.textContent = resp.publicKey.toString().substr(0, 4) + "..." + resp.publicKey.toString().substr(-4);
                    walletOverlay.style.display = 'none';
                    connection = new solanaWeb3.Connection("https://api.devnet.solana.com");
                    showMintStatus("팬텀 지갑 연결 완료!", "green");
                } catch (err) {
                    console.error("연결 과정 오류:", err);
                    walletErrorMessage.textContent = "연결을 거부했거나 오류가 발생했습니다.";
                    showMintStatus("연결을 거부했거나 오류가 발생했습니다", "red");
                }
            } catch (err) {
                console.error("지갑 연결 전체 오류:", err);
                walletErrorMessage.textContent = "지갑 연결에 실패했습니다.";
                showMintStatus("지갑 연결 실패", "red");
            }
        }
        
        async function connectSolflareWallet() {
            console.log("솔플레어 지갑 연결 시도...");
            walletErrorMessage.textContent = "";
            
            try {
                // Solflare 지갑이 설치되어 있는지 확인
                const isSolflareInstalled = window.solflare?.isSolflare;
                
                if (!isSolflareInstalled) {
                    console.log("솔플레어 지갑이 설치되지 않음");
                    walletErrorMessage.textContent = "솔플레어 지갑이 설치되어 있지 않습니다. 설치 후 다시 시도해주세요.";
                    return;
                }
                
                console.log("솔플레어 지갑 감지됨, 연결 시도 중...");
                
                try {
                    // 연결 요청
                    await window.solflare.connect();
                    
                    if (window.solflare.connected) {
                        console.log("연결 성공:", window.solflare.publicKey.toString());
                        
                        wallet = window.solflare;
                        walletConnected = true;
                        currentWalletType = 'solflare';
                        walletButton.textContent = window.solflare.publicKey.toString().substr(0, 4) + "..." + window.solflare.publicKey.toString().substr(-4);
                        walletOverlay.style.display = 'none';
                        connection = new solanaWeb3.Connection("https://api.devnet.solana.com");
                        showMintStatus("솔플레어 지갑 연결 완료!", "green");
                    } else {
                        walletErrorMessage.textContent = "연결이 완료되지 않았습니다.";
                    }
                } catch (err) {
                    console.error("연결 과정 오류:", err);
                    walletErrorMessage.textContent = "연결을 거부했거나 오류가 발생했습니다.";
                    showMintStatus("연결을 거부했거나 오류가 발생했습니다", "red");
                }
            } catch (err) {
                console.error("지갑 연결 전체 오류:", err);
                walletErrorMessage.textContent = "지갑 연결에 실패했습니다.";
                showMintStatus("지갑 연결 실패", "red");
            }
        }
        
        // 기존 connectWallet 함수를 남겨두고 백업용으로 사용
        async function connectWallet() {
            if (currentWalletType === 'phantom') {
                await connectPhantomWallet();
            } else if (currentWalletType === 'solflare') {
                await connectSolflareWallet();
            } else {
                // 기본적으로 팬텀 시도
                await connectPhantomWallet();
            }
        }
        
        async function mintToken(enemyType) {
            if (!walletConnected || mintCooldown || mintPending) {
                console.log("민팅 불가:", !walletConnected ? "지갑 연결 안됨" : mintCooldown ? "쿨다운 중" : "이미 진행 중");
                return;
            }
            
            // 커스텀 지갑 사용 시 쿠키 확인
            if (currentWalletType === 'custom') {
                // 쿠키 확인
                const hasValidCookie = checkEmailCookieValid();
                if (!hasValidCookie) {
                    showMintStatus("인증 세션 만료됨. 다시 로그인 필요", "red");
                    return;
                }
            }
            
            // 민팅 진행중 표시
            console.log("민팅 시작:", enemyType);
            mintPending = true;
            updateMintProgress(10);
            
            // 민팅 쿨다운 설정
            mintCooldown = true;
            mintCooldownTimer = MINT_COOLDOWN;
            
            try {
                // 민팅 절차 시뮬레이션 (실제로는 솔라나 트랜잭션 구성 필요)
                showMintStatus("토큰 민팅 중...", "yellow");
                updateMintProgress(30);
                
                // 적 타입에 따른 토큰 이름 설정
                let tokenName = "";
                if (enemyType === 'normal') {
                    tokenName = "NORMAL";
                } else if (enemyType === 'fast') {
                    tokenName = "SPEED";
                } else if (enemyType === 'shooter') {
                    tokenName = "RANGER";
                }
                
                console.log(`${tokenName} 토큰 민팅 중...`);
                
                // 솔라나 트랜잭션 시뮬레이션
                updateMintProgress(60);
                
                try {
                    // 테스트 모드일 경우 트랜잭션 시뮬레이션만 수행
                    if (currentWalletType === 'test') {
                        console.log("테스트 모드: 트랜잭션 시뮬레이션");
                        try {
                            // 트랜잭션 서명 요청 시뮬레이션 (팝업 표시)
                            await wallet.signTransaction({ dummy: true });
                            
                            // 짧은 지연 시간 추가 (실제 트랜잭션 흐름 시뮬레이션)
                            await new Promise(resolve => setTimeout(resolve, 300));
                        } catch (err) {
                            // 사용자가 서명을 거부한 경우
                            console.log("테스트 모드: 사용자가 트랜잭션을 거부함");
                            showMintStatus("트랜잭션 서명이 거부되었습니다", "red");
                            updateMintProgress(0);
                            mintPending = false;
                            return;
                        }
                    } else {
                        // 실제 트랜잭션 수행
                        const recentBlockhash = await connection.getRecentBlockhash();
                        console.log("최근 블록해시 가져옴:", recentBlockhash.blockhash);
                        
                        const transaction = new solanaWeb3.Transaction().add(
                            solanaWeb3.SystemProgram.transfer({
                                fromPubkey: wallet.publicKey,
                                toPubkey: wallet.publicKey,
                                lamports: 100, // 아주 소량의 SOL (테스트용)
                            })
                        );
                        
                        transaction.feePayer = wallet.publicKey;
                        transaction.recentBlockhash = recentBlockhash.blockhash;
                        
                        console.log("트랜잭션 생성 완료, 서명 요청 중...");
                        const signed = await wallet.signTransaction(transaction);
                        console.log("서명 완료, 트랜잭션 전송 중...");
                        
                        // 트랜잭션 전송
                        const signature = await connection.sendRawTransaction(signed.serialize());
                        console.log("트랜잭션 전송됨:", signature);
                        
                        // 트랜잭션 확인
                        await connection.confirmTransaction(signature);
                        console.log("트랜잭션 확인됨");
                    }
                } catch (txError) {
                    console.error("트랜잭션 오류:", txError);
                    // 사용자가 거부한 경우인지 체크
                    if (txError.message && txError.message.includes('rejected')) {
                        showMintStatus("트랜잭션 서명이 거부되었습니다", "red");
                        updateMintProgress(0);
                        mintPending = false;
                        return;
                    }
                    // 트랜잭션 실패해도 게임에서는 성공한 것처럼 처리
                    console.log("트랜잭션 실패했지만 게임은 계속됩니다");
                }
                
                // 민팅 성공 처리
                mintedTokens++;
                mintedTokensElement.textContent = `민팅된 토큰: ${mintedTokens}`;
                updateMintProgress(100);
                
                // 커스텀 지갑인 경우 사용자 정보 표시
                if (currentWalletType === 'custom' && wallet.userInfo) {
                    showMintStatus(`${tokenName} 토큰 민팅 성공! (${wallet.userInfo.email})`, "green");
                } else {
                    showMintStatus(`${tokenName} 토큰 민팅 성공!`, "green");
                }
                
                // 지연 후 프로그레스 바 초기화
                setTimeout(() => {
                    updateMintProgress(0);
                }, 2000);
                
            } catch (err) {
                console.error("민팅 오류:", err);
                showMintStatus("민팅 실패", "red");
                updateMintProgress(0);
            }
            
            mintPending = false;
        }
        
        function showMintStatus(message, color) {
            mintStatusElement.textContent = message;
            mintStatusElement.style.color = color;
            
            // 상태 메시지 자동 숨김
            setTimeout(() => {
                mintStatusElement.textContent = '';
            }, 3000);
        }
        
        function updateMintProgress(percent) {
            mintProgressBar.style.width = `${percent}%`;
        }

        // --- 클래스 정의 ---
        class Particle { /* 이전과 동일 */ constructor(x,y,r,c,v){this.x=x;this.y=y;this.radius=r;this.color=c;this.velocity=v;this.alpha=1;this.friction=0.98;} draw(){ctx.save();ctx.globalAlpha=this.alpha;ctx.beginPath();ctx.arc(this.x,this.y,this.radius,0,Math.PI*2,false);ctx.fillStyle=this.color;ctx.shadowColor=this.color;ctx.shadowBlur=5;ctx.fill();ctx.restore();} update(){this.velocity.x*=this.friction;this.velocity.y*=this.friction;this.x+=this.velocity.x;this.y+=this.velocity.y;this.alpha-=0.03;} }
        class HealthPickup { /* 이전과 동일 */ constructor(x,y){this.x=x;this.y=y;this.size=12;this.color=pickupColor;this.glow=pickupGlow;this.healAmount=20;this.life=360;} draw(){ctx.save();ctx.fillStyle=this.color;ctx.shadowColor=this.glow;ctx.shadowBlur=10;ctx.fillRect(this.x-this.size/2,this.y-this.size/2,this.size,this.size);ctx.fillStyle='white';ctx.fillRect(this.x-this.size*0.1,this.y-this.size*0.3,this.size*0.2,this.size*0.6);ctx.fillRect(this.x-this.size*0.3,this.y-this.size*0.1,this.size*0.6,this.size*0.2);ctx.restore();} update(){this.life--;} }
        class Player { /* 이전과 동일 */ constructor(x,y,s,c,sp){this.x=x;this.y=y;this.size=s;this.color=playerColor;this.glow=playerGlow;this.baseSpeed=sp;this.maxHealth=100;this.health=this.maxHealth;this.angle=0;this.fireRateLevel=0;this.baseFireCooldown=20;this.fireCooldown=this.baseFireCooldown;this.fireTimer=0;this.upgradePoints=0;this.bulletDamage=1;this.bulletSpreadLevel=0;this.dashCooldownLevel=0;this.baseDashCooldown=120;this.dashCooldown=this.baseDashCooldown;this.minDashCooldown=30;this.dashCooldownReduction=15;this.dashTimer=0;this.dashDuration=10;this.dashDistance=100;this.isDashing=false;this.dashCurrentDuration=0;this.dashStartX=0;this.dashStartY=0;this.dashTargetX=0;this.dashTargetY=0;this.trail=[];
        // 대시 무적 상태 추가
        this.isInvincible=false;
        this.invincibilityDuration=25; // 무적 시간 증가 (프레임 단위)
        this.invincibilityTimer=0; 
    } draw(){this.angle=Math.atan2(mousePos.y-this.y,mousePos.x-this.x);ctx.save();ctx.translate(this.x,this.y);ctx.rotate(this.angle);

    // 무적 상태일 때 깜빡임 효과 추가
    const isVisible = !this.isInvincible || (Math.floor(Date.now() / 50) % 2 === 0);
    ctx.globalAlpha = isVisible ? 1 : 0.3;

    this.trail.forEach((p)=>{ctx.save();ctx.globalAlpha=p.alpha * (isVisible ? 1 : 0.3);ctx.translate(p.x-this.x,p.y-this.y);ctx.rotate(p.angle-this.angle);ctx.beginPath();ctx.moveTo(this.size*0.8,0);ctx.lineTo(-this.size*0.4,-this.size*0.5);ctx.lineTo(-this.size*0.4,this.size*0.5);ctx.closePath();ctx.fillStyle=this.glow;ctx.fill();ctx.restore();});ctx.beginPath();ctx.moveTo(this.size,0);ctx.lineTo(this.size*0.3,-this.size*0.4);ctx.lineTo(-this.size*0.6,-this.size*0.5);ctx.lineTo(-this.size*0.4,0);ctx.lineTo(-this.size*0.6,this.size*0.5);ctx.lineTo(this.size*0.3,this.size*0.4);ctx.closePath();ctx.fillStyle=this.color;ctx.shadowColor=this.glow;ctx.shadowBlur=15;ctx.fill();ctx.strokeStyle='rgba(255,255,255,0.7)';ctx.lineWidth=1;ctx.beginPath();ctx.moveTo(-this.size*0.4,0);ctx.lineTo(this.size*0.8,0);ctx.stroke();ctx.restore();const hBW=40;const hBH=6;const hBX=this.x-hBW/2;const hBY=this.y-this.size*1.5-hBH;ctx.fillStyle='#555';ctx.fillRect(hBX,hBY,hBW,hBH);const cHW=hBW*(this.health/this.maxHealth);ctx.fillStyle=this.health>30?this.color:'#f00';ctx.fillRect(hBX,hBY,Math.max(0,cHW),hBH);} update(){if(this.fireTimer>0)this.fireTimer--;if(this.dashTimer>0)this.dashTimer--;

    // 무적 타이머 업데이트
    if(this.isInvincible) {
        this.invincibilityTimer--;
        if(this.invincibilityTimer <= 0) {
            this.isInvincible = false;
        }
    }

    this.trail=this.trail.filter(p=>p.alpha>0);this.trail.forEach(p=>p.alpha-=0.05);if(this.isDashing){this.dashCurrentDuration++;let t=this.dashCurrentDuration/this.dashDuration;t=t<0?0:t>1?1:t;t=t*(2-t);this.x=lerp(this.dashStartX,this.dashTargetX,t);this.y=lerp(this.dashStartY,this.dashTargetY,t);if(this.dashCurrentDuration%2===0){this.trail.push({x:this.x,y:this.y,angle:this.angle,alpha:0.6});}if(this.dashCurrentDuration>=this.dashDuration){this.isDashing=false;this.x=this.dashTargetX;this.y=this.dashTargetY;}}if(this.dashTimer>0){dashStatusElement.textContent=`Dash: ${(this.dashTimer/60).toFixed(1)}s`;dashStatusElement.style.color='#aaa';}else{dashStatusElement.textContent=`Dash: READY`;dashStatusElement.style.color='#0ff';}} triggerDash(){if(this.dashTimer<=0&&!this.isDashing){this.isDashing=true;this.dashCurrentDuration=0;this.dashTimer=this.dashCooldown;this.dashStartX=this.x;this.dashStartY=this.y;const a=Math.atan2(mousePos.y-this.y,mousePos.x-this.x);let tX=this.x+Math.cos(a)*this.dashDistance;let tY=this.y+Math.sin(a)*this.dashDistance;this.dashTargetX=Math.max(this.size,Math.min(canvas.width-this.size,tX));this.dashTargetY=Math.max(this.size,Math.min(canvas.height-this.size,tY));createExplosion(this.x,this.y,'white',8,3);

    // 대시 시 무적 상태 활성화
    this.isInvincible = true;
    this.invincibilityTimer = this.invincibilityDuration;
}} takeDamage(amount){
// 무적 상태면 데미지 무시
if(this.isInvincible) return;

this.health-=amount;triggerScreenShake(6,12);if(this.health<=0){this.health=0;gameOver=true;createExplosion(this.x,this.y,this.color,30,4);}else{createExplosion(this.x,this.y,'red',5,2);}} heal(amount){this.health=Math.min(this.maxHealth,this.health+amount);createExplosion(this.x,this.y,pickupColor,10,3);} shoot(){if(this.fireTimer<=0){const bS=7;const mX=this.x+Math.cos(this.angle)*this.size;const mY=this.y+Math.sin(this.angle)*this.size;const bTS=this.bulletSpreadLevel+1;const sA=Math.PI/18;for(let i=0;i<bTS;i++){const cA=this.angle-(sA*this.bulletSpreadLevel/2)+(i*sA);const v={x:Math.cos(cA)*bS,y:Math.sin(cA)*bS};bullets.push(new Bullet(mX,mY,4,bulletColor,v));}this.fireTimer=this.fireCooldown;}} upgradeFireRate(){this.fireRateLevel++;this.fireCooldown=Math.max(5,this.baseFireCooldown-this.fireRateLevel*2);showUpgradeMessage("Fire Rate Matrix Optimized!");} upgradeDamage(){this.bulletDamage+=0.5;showUpgradeMessage(`Damage Output Increased! (${this.bulletDamage.toFixed(1)})`);} upgradeSpread(){if(this.bulletSpreadLevel<4){this.bulletSpreadLevel++;showUpgradeMessage(`Projectile Spread Enhanced! (${this.bulletSpreadLevel+1})`);}else{showUpgradeMessage(`Spread Matrix Maxed!`);}} upgradeDashCooldown(){this.dashCooldownLevel++;this.dashCooldown=Math.max(this.minDashCooldown,this.baseDashCooldown-this.dashCooldownLevel*this.dashCooldownReduction);showUpgradeMessage(`Dash Recalibration Complete! (${(this.dashCooldown/60).toFixed(1)}s)`);} addUpgradePoint(){this.upgradePoints++;updateUpgradeUI();} spendUpgradePoint(){if(this.upgradePoints>0){this.upgradePoints--;updateUpgradeUI();return true;}return false;} }
        class Bullet { /* 이전과 동일 */ constructor(x,y,r,c,v){this.x=x;this.y=y;this.radius=r;this.color=c;this.glow=bulletGlow;this.velocity=v;} draw(){ctx.beginPath();ctx.arc(this.x,this.y,this.radius,0,Math.PI*2,false);ctx.fillStyle=this.color;ctx.shadowColor=this.glow;ctx.shadowBlur=8;ctx.fill();ctx.shadowColor='transparent';ctx.shadowBlur=0;ctx.closePath();} update(){this.x+=this.velocity.x;this.y+=this.velocity.y;} }
        class EnemyBullet { /* 이전과 동일 */ constructor(x,y,r,c,v){this.x=x;this.y=y;this.radius=r;this.color=enemyBulletColor;this.velocity=v;} draw(){ctx.beginPath();ctx.arc(this.x,this.y,this.radius,0,Math.PI*2,false);ctx.fillStyle=this.color;ctx.shadowColor='red';ctx.shadowBlur=5;ctx.fill();ctx.shadowColor='transparent';ctx.shadowBlur=0;ctx.closePath();} update(){this.x+=this.velocity.x;this.y+=this.velocity.y;} }
        class Enemy {
            constructor(x,y,s,c,sp,h=1,t='normal'){
                this.x=x;
                this.y=y;
                this.size=s;
                
                if(t==='normal'){
                    this.color=enemyNormalColor;
                    this.glow=enemyNormalGlow;
                } else if(t==='fast'){
                    this.color=enemyFastColor;
                    this.glow=enemyFastGlow;
                } else if(t==='shooter'){
                    this.color=enemyShooterColor;
                    this.glow=enemyShooterGlow;
                } else {
                    this.color=c;
                    this.glow=c;
                }
                
                const dm = difficultyMultipliers[currentDifficulty];
                this.baseSpeed=sp;
                this.baseHealth=h;
                this.type=t;
                this.speed=sp*(1+(difficultyMultiplier-1)*0.8) * dm.enemySpeed;
                this.maxHealth=Math.ceil(h*(1+(difficultyMultiplier-1)*0.6) * dm.enemyHealth);
                this.health=this.maxHealth;
                this.shootCooldown=120 / dm.enemySpeed;  // 난이도 높을수록 발사 속도도 빨라짐
                this.shootTimer=Math.random()*this.shootCooldown;
            }
            
            draw(){
                ctx.save();
                ctx.fillStyle=this.color;
                ctx.shadowColor=this.glow;
                ctx.shadowBlur=10;
                
                if(this.type==='shooter'){
                    ctx.beginPath();
                    ctx.arc(this.x,this.y,this.size*0.6,0,Math.PI*2);
                    ctx.fill();
                    ctx.save();
                    ctx.translate(this.x,this.y);
                    ctx.rotate(Math.atan2(player.y-this.y,player.x-this.x));
                    ctx.fillStyle='grey';
                    ctx.shadowBlur=0;
                    ctx.fillRect(0,-this.size*0.15,this.size*0.8,this.size*0.3);
                    ctx.restore();
                } else if(this.type==='fast'){
                    ctx.beginPath();
                    ctx.moveTo(this.x,this.y+this.size*0.6);
                    ctx.lineTo(this.x-this.size*0.5,this.y-this.size*0.4);
                    ctx.lineTo(this.x,this.y-this.size*0.1);
                    ctx.lineTo(this.x+this.size*0.5,this.y-this.size*0.4);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    const cR=this.size*0.2;
                    ctx.beginPath();
                    ctx.moveTo(this.x-this.size/2+cR,this.y-this.size/2);
                    ctx.lineTo(this.x+this.size/2-cR,this.y-this.size/2);
                    ctx.quadraticCurveTo(this.x+this.size/2,this.y-this.size/2,this.x+this.size/2,this.y-this.size/2+cR);
                    ctx.lineTo(this.x+this.size/2,this.y+this.size/2-cR);
                    ctx.quadraticCurveTo(this.x+this.size/2,this.y+this.size/2,this.x+this.size/2-cR,this.y+this.size/2);
                    ctx.lineTo(this.x-this.size/2+cR,this.y+this.size/2);
                    ctx.quadraticCurveTo(this.x-this.size/2,this.y+this.size/2,this.x-this.size/2,this.y+this.size/2-cR);
                    ctx.lineTo(this.x-this.size/2,this.y-this.size/2+cR);
                    ctx.quadraticCurveTo(this.x-this.size/2,this.y-this.size/2,this.x-this.size/2+cR,this.y-this.size/2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle='rgba(255,255,255,0.3)';
                    ctx.shadowBlur=0;
                    ctx.beginPath();
                    ctx.arc(this.x,this.y,this.size*0.2,0,Math.PI*2);
                    ctx.fill();
                }
                
                ctx.restore();
                
                if(this.maxHealth>1 && (this.type==='normal' || this.type==='shooter')) {
                    const hBW=this.size;
                    const hBH=4;
                    const hBX=this.x-hBW/2;
                    const hBY=this.y-this.size/2-hBH-2;
                    ctx.fillStyle='#555';
                    ctx.fillRect(hBX,hBY,hBW,hBH);
                    const cHW=hBW*(this.health/this.maxHealth);
                    ctx.fillStyle='#f00';
                    ctx.fillRect(hBX,hBY,Math.max(0,cHW),hBH);
                }
            }
            
            update(){
                const dm = difficultyMultipliers[currentDifficulty];
                this.speed=this.baseSpeed*(1+(difficultyMultiplier-1)*0.8) * dm.enemySpeed;
                
                const aTP=Math.atan2(player.y-this.y,player.x-this.x);
                
                if(this.type==='shooter'){
                    const dD=200;
                    const cD=distance(this.x,this.y,player.x,player.y);
                    let mA=aTP;
                    
                    if(cD<dD-20){
                        mA+=Math.PI;
                    } else if(cD<=dD+20){
                        mA+=Math.PI/2*Math.sign(Math.cos(Date.now()/500));
                    }
                    
                    this.x+=Math.cos(mA)*this.speed*0.7;
                    this.y+=Math.sin(mA)*this.speed*0.7;
                    
                    this.shootTimer++;
                    if(this.shootTimer>=this.shootCooldown){
                        this.shootTimer=0;
                        const bS=3*difficultyMultiplier * dm.enemySpeed;
                        const v={x:Math.cos(aTP)*bS,y:Math.sin(aTP)*bS};
                        enemyBullets.push(new EnemyBullet(this.x,this.y,5,'red',v));
                    }
                } else {
                    this.x+=Math.cos(aTP)*this.speed;
                    this.y+=Math.sin(aTP)*this.speed;
                }
                
                this.x=Math.max(this.size/2,Math.min(canvas.width-this.size/2,this.x));
                this.y=Math.max(this.size/2,Math.min(canvas.height-this.size/2,this.y));
            }
            
            takeDamage(damage){
                this.health-=damage;
                createExplosion(this.x,this.y,this.color,3,1.5);
                return this.health<=0;
            }
        }

        // --- 헬퍼 함수 (이전과 동일) ---
        function lerp(s,e,t){return s*(1-t)+e*t;} function distance(x1,y1,x2,y2){const xD=x2-x1;const yD=y2-y1;return Math.sqrt(xD*xD+yD*yD);} function detectCollisionCircleRect(c,r){const cX=Math.max(r.x-r.size/2,Math.min(c.x,r.x+r.size/2));const cY=Math.max(r.y-r.size/2,Math.min(c.y,r.y+r.size/2));const d=distance(c.x,c.y,cX,cY);return d<c.radius;} function detectCollisionPlayerEnemy(p,e){const pC={x:p.x,y:p.y,radius:p.size*0.8};if(e.type==='shooter'){return detectCollisionCircleRect(pC,{x:e.x,y:e.y,size:e.size*1.4});}else{return detectCollisionCircleRect(pC,e);}} function detectCollisionPlayerPickup(p,pk){const d=distance(p.x,p.y,pk.x,pk.y);return d<p.size*0.8+pk.size/2;} function detectCollisionBulletPlayer(b,p){const d=distance(b.x,b.y,p.x,p.y);return d<b.radius+p.size*0.7;} function updateMousePos(e){const r=canvas.getBoundingClientRect();mousePos.x=e.clientX-r.left;mousePos.y=e.clientY-r.top;} function createExplosion(x,y,c,cnt=10,sM=3){for(let i=0;i<cnt;i++){const r=Math.random()*sM+1;const v={x:(Math.random()-0.5)*(Math.random()*7),y:(Math.random()-0.5)*(Math.random()*7)};particles.push(new Particle(x,y,r,c,v));}} 
        
        // 적 생성 함수를 난이도에 맞게 수정
        function spawnEnemy(){
            let s,c,bS,bH,t;
            const eTR=Math.random();
            const cSS=score>=SHOOTER_ENEMY_SCORE_THRESHOLD;
            const dm = difficultyMultipliers[currentDifficulty];
            
            if(cSS&&eTR<0.15){
                t='shooter';
                s=20;
                c=enemyShooterColor;
                bS=0.8 * dm.enemySpeed;
                bH=5 * dm.enemyHealth;
            }else if(eTR<0.35){
                t='fast';
                s=Math.random()*10+10;
                c=enemyFastColor;
                bS=(Math.random()*1.5+1.0) * dm.enemySpeed;
                bH=0.5 * dm.enemyHealth;
            }else{
                t='normal';
                s=Math.random()*20+15;
                c=enemyNormalColor;
                bS=(Math.random()*1+0.5) * dm.enemySpeed;
                bH=(Math.random()<0.1?3:1) * dm.enemyHealth;
            }
            
            let x,y;
            if(Math.random()<0.5){
                x=Math.random()<0.5?0-s:canvas.width+s;
                y=Math.random()*canvas.height;
            }else{
                x=Math.random()*canvas.width;
                y=Math.random()<0.5?0-s:canvas.height+s;
            }
            
            enemies.push(new Enemy(x,y,s,c,bS,bH,t));
        } 
        
        function showUpgradeMessage(m){upgradeMessageElement.textContent=m;clearTimeout(upgradeMessageTimeout);upgradeMessageElement.style.opacity=1;upgradeMessageTimeout=setTimeout(()=>{upgradeMessageElement.style.opacity=0;},2000);} function updateUpgradeUI(){if(!player)return;upgradePointsElement.textContent=`Creds: ${player.upgradePoints}`;if(currentUpgradeLevel<scoreThresholds.length){const nT=scoreThresholds[currentUpgradeLevel];const pN=Math.max(0,nT-score);nextUpgradeProgressElement.textContent=`Next: ${score}/${nT}pts`;}else{nextUpgradeProgressElement.textContent="Next: MAX";}firerateLabel.textContent=`Cool: ${player.fireCooldown}`;damageLabel.textContent=`Dmg: ${player.bulletDamage.toFixed(1)}`;spreadLabel.textContent=`Proj: ${player.bulletSpreadLevel+1}`;dashLabel.textContent=`Cool: ${(player.dashCooldown/60).toFixed(1)}s`;} function triggerScreenShake(i,d){screenShakeIntensity=i;screenShakeDuration=d;}

        // --- 게임 초기화 ---
        function startGame() {
            highScore=localStorage.getItem('shooterHighScore')||0;
            highScoreElement.textContent=`High: ${highScore}`;
            player=new Player(canvas.width/2,canvas.height/2,15,playerColor,3.5);
            bullets=[];
            enemies=[];
            enemyBullets=[];
            particles=[];
            pickups=[];
            score=0;
            gameOver=false;
            isPaused=false;
            keys={};
            mousePos={x:canvas.width/2,y:canvas.height/2};
            enemySpawnTimer=0;
            
            // 민팅 관련 초기화
            mintCooldown = false;
            mintCooldownTimer = 0;
            updateMintProgress(0);
            
            // 난이도에 따른 적 스폰 간격 설정
            currentEnemySpawnInterval = baseEnemySpawnInterval / difficultyMultipliers[currentDifficulty].enemySpawn;
            
            difficultyMultiplier=1.0;
            currentUpgradeLevel=0;
            scoreElement.textContent=`Score: ${score}`;
            updateUpgradeUI();
            messageBox.style.display='none';
            newHighScoreMessageElement.style.display='none';
            upgradeChoiceOverlay.style.display='none';
            upgradeMessageElement.style.opacity=0;
            
            
            // 이벤트 리스너 설정
            setupEventListeners();
            
            // 게임 루프 시작
            if(gameLoopId) cancelAnimationFrame(gameLoopId);
            gameLoop();
        }
        
        function setupEventListeners() {
            // 이전 이벤트 리스너 제거
            window.removeEventListener('keydown',handleKeyDown);
            window.removeEventListener('keyup',handleKeyUp);
            canvas.removeEventListener('mousemove',updateMousePos);
            canvas.removeEventListener('mousedown',handleMouseDown);
            restartButton.removeEventListener('click',init);
            upgradeFirerateButton.removeEventListener('click',handleUpgradeChoice);
            upgradeDamageButton.removeEventListener('click',handleUpgradeChoice);
            upgradeSpreadButton.removeEventListener('click',handleUpgradeChoice);
            upgradeDashButton.removeEventListener('click',handleUpgradeChoice);
            walletButton.removeEventListener('click',handleWalletButton);
            connectWalletButton.removeEventListener('click',connectPhantomWallet);
            connectSolflareButton.removeEventListener('click',connectSolflareWallet);
            connectTestButton.removeEventListener('click',connectTestMode);
            connectSlopeButton.removeEventListener('click',connectSlopeWallet);
            walletAdapterButton.removeEventListener('click',showAllWallets);
            signApproveButton.removeEventListener('click', handleSignatureApprove);
            signRejectButton.removeEventListener('click', handleSignatureReject);
            document.getElementById('connect-custom-button').removeEventListener('click', connectCustomWallet);
            
            // 이벤트 리스너 추가
            window.addEventListener('keydown',handleKeyDown);
            window.addEventListener('keyup',handleKeyUp);
            canvas.addEventListener('mousemove',updateMousePos);
            canvas.addEventListener('mousedown',handleMouseDown);
            restartButton.addEventListener('click',init);
            upgradeFirerateButton.addEventListener('click',handleUpgradeChoice);
            upgradeDamageButton.addEventListener('click',handleUpgradeChoice);
            upgradeSpreadButton.addEventListener('click',handleUpgradeChoice);
            upgradeDashButton.addEventListener('click',handleUpgradeChoice);
            walletButton.addEventListener('click',handleWalletButton);
            connectWalletButton.addEventListener('click',connectPhantomWallet);
            connectSolflareButton.addEventListener('click',connectSolflareWallet);
            connectTestButton.addEventListener('click',connectTestMode);
            connectSlopeButton.addEventListener('click',connectSlopeWallet);
            walletAdapterButton.addEventListener('click',showAllWallets);
            signApproveButton.addEventListener('click', handleSignatureApprove);
            signRejectButton.addEventListener('click', handleSignatureReject);
            document.getElementById('connect-custom-button').addEventListener('click', connectCustomWallet);
            
            // 인증 쿠키 주기적 확인 설정
            startCookieCheckInterval();
        }
        
        // 인증 쿠키 주기적 확인 함수
        function startCookieCheckInterval() {
            // 이미 설정된 인터벌이 있으면 제거
            if (window.authCookieCheckInterval) {
                clearInterval(window.authCookieCheckInterval);
            }
            
            // 60초마다 쿠키 체크 (1분)
            window.authCookieCheckInterval = setInterval(() => {
                if (currentWalletType === 'custom' && walletConnected) {
                    const isValid = checkEmailCookieValid();
                    console.log("인증 쿠키 확인:", isValid ? "유효함" : "만료됨");
                    
                    if (!isValid) {
                        // 쿠키가 만료되었거나 없음 - 경고 표시
                        showMintStatus("인증 세션이 만료되었습니다. 다시 로그인 필요", "red");
                    }
                }
            }, 60000); // 60초마다
        }
        
        function init() {
            // 난이도 선택 화면 표시
            difficultyOverlay.style.display = 'flex';
        }
        
        // 지갑 버튼 핸들러
        function handleWalletButton() {
            if (!walletConnected) {
                walletOverlay.style.display = 'flex';
            } else {
                showMintStatus("이미 연결되었습니다", "green");
            }
        }

        // 난이도 선택 이벤트 핸들러
        function handleDifficultyChoice(difficulty) {
            currentDifficulty = difficulty;
            difficultyOverlay.style.display = 'none';
            
            // 난이도에 따른 UI 업데이트
            if(difficulty === 'easy') {
                difficultyValueElement.textContent = "난이도: 쉬움";
                difficultyValueElement.style.color = "#00ff00";
            } else if(difficulty === 'normal') {
                difficultyValueElement.textContent = "난이도: 보통";
                difficultyValueElement.style.color = "#ffff00";
            } else {
                difficultyValueElement.textContent = "난이도: 어려움";
                difficultyValueElement.style.color = "#ff0000";
            }
            
            // 게임 시작
            startGame();
            
            // 난이도 메시지 표시
            showUpgradeMessage(`${difficulty === 'easy' ? '쉬움' : difficulty === 'normal' ? '보통' : '어려움'} 난이도로 시작!`);
        }

        // --- 입력 처리 (이전과 동일) ---
        function handleKeyDown(event){const k=event.key.toLowerCase();keys[k]=true;if(k==='shift'&&!isPaused&&!gameOver){player.triggerDash();}}
        function handleKeyUp(event){keys[event.key.toLowerCase()]=false;}
        function handleMouseDown(event){if(!gameOver&&!isPaused){player.shoot();}}
        function handleUpgradeChoice(event){if(!player||player.upgradePoints<=0)return;if(player.spendUpgradePoint()){const c=event.target.id;if(c==='upgrade-firerate')player.upgradeFireRate();else if(c==='upgrade-damage')player.upgradeDamage();else if(c==='upgrade-spread')player.upgradeSpread();else if(c==='upgrade-dash')player.upgradeDashCooldown();updateUpgradeUI();upgradeChoiceOverlay.style.display='none';isPaused=false;}}

        // --- 게임 루프, 로직 업데이트, 그리기 함수 (이전과 동일) ---
        function gameLoop(){if(gameOver){finalScoreElement.textContent=`Job Score: ${score}`;if(score>highScore){highScore=score;localStorage.setItem('shooterHighScore',highScore);highScoreElement.textContent=`High: ${highScore}`;newHighScoreMessageElement.style.display='block';}else{newHighScoreMessageElement.style.display='none';}messageBox.style.display='flex';return;} gameLoopId=requestAnimationFrame(gameLoop); if(player.upgradePoints>0&&!isPaused){isPaused=true;updateUpgradeUI();upgradeChoiceOverlay.style.display='flex';} if(!isPaused){updateGameLogic();} drawGameElements();}
        function updateGameLogic(){
            const dm = difficultyMultipliers[currentDifficulty];
            difficultyMultiplier=1+(score/7000);
            
            player.update();
            
            // 민팅 쿨다운 업데이트
            if(mintCooldown) {
                mintCooldownTimer--;
                if(mintCooldownTimer <= 0) {
                    mintCooldown = false;
                }
            }
            
            bullets=bullets.filter(b=>b.x+b.radius>0&&b.x-b.radius<canvas.width&&b.y+b.radius>0&&b.y-b.radius<canvas.height);
            bullets.forEach(b=>b.update());
            
            enemyBullets=enemyBullets.filter(eb=>eb.x+eb.radius>0&&eb.x-eb.radius<canvas.width&&eb.y+eb.radius>0&&eb.y-eb.radius<canvas.height);
            enemyBullets.forEach(eb=>eb.update());
            
            particles=particles.filter(p=>p.alpha>0);
            particles.forEach(p=>p.update());
            
            pickups=pickups.filter(p=>p.life>0);
            pickups.forEach(p=>p.update());
            
            enemySpawnTimer++;
            
            // 난이도에 따른 적 스폰 간격 조정
            currentEnemySpawnInterval=Math.max(
                minEnemySpawnInterval,
                baseEnemySpawnInterval/(difficultyMultiplier*0.5+0.5) / dm.enemySpawn
            );
            
            if(enemySpawnTimer>=currentEnemySpawnInterval){
                spawnEnemy();
                enemySpawnTimer=0;
            } 
            
            pickups.forEach((p,i)=>{
                if(detectCollisionPlayerPickup(player,p)){
                    player.heal(p.healAmount);
                    pickups.splice(i,1);
                    showUpgradeMessage(`Nano-Medkit Acquired! +${p.healAmount}`);
                }
            }); 
            
            enemyBullets=enemyBullets.filter(eb=>{
                if(detectCollisionBulletPlayer(eb,player)){
                    // 무적 상태가 아닐 때만 데미지
                    if(!player.isInvincible) {
                        // 난이도에 따른 데미지 조정
                        player.takeDamage(10 * dm.enemyDamage);
                    }
                    // 총알은 항상 제거
                    createExplosion(eb.x,eb.y,eb.color,5,1.5);
                    return false;
                }
                return true;
            }); 
            
            if(gameOver) return; 
            
            const remainingEnemies=[];
            enemies.forEach(enemy=>{
                enemy.update();
                let enemyAlive=true;
                
                if(detectCollisionPlayerEnemy(player,enemy)){
                    // 무적 상태가 아닐 때만 데미지
                    if(!player.isInvincible) {
                        // 난이도에 따른 데미지 조정
                        player.takeDamage(Math.ceil((10+5*(difficultyMultiplier-1)) * dm.enemyDamage));
                    }
                    
                    // 충돌 효과는 항상 표시
                    createExplosion(enemy.x,enemy.y,enemy.color,15);
                    enemyAlive=false;
                    if(gameOver) return;
                } 
                
                if(enemyAlive){
                    bullets=bullets.filter(bullet=>{
                        if(detectCollisionCircleRect(bullet,enemy)){
                            if(enemy.takeDamage(player.bulletDamage)){
                                // 난이도에 따른 점수 조정
                                let sG=(enemy.type==='fast'?15:(enemy.type==='shooter'?20:10))*Math.ceil(difficultyMultiplier);
                                score+=Math.round(sG * dm.scoreMultiplier);
                                scoreElement.textContent=`Score: ${score}`;
                                createExplosion(enemy.x,enemy.y,enemy.color,15);
                                enemyAlive=false;
                                
                                // 솔라나 민팅 시도 (테스트 모드나 지갑이 연결된 경우)
                                if(walletConnected && (currentWalletType === 'phantom' || currentWalletType === 'solflare' || currentWalletType === 'test' || currentWalletType === 'custom' || currentWalletType === 'slope')) {
                                    mintToken(enemy.type);
                                } else {
                                    // 지갑이 연결되지 않은 경우 알림
                                    showMintStatus("지갑 연결 필요!", "yellow");
                                }
                                
                                if(Math.random()<0.05){
                                    pickups.push(new HealthPickup(enemy.x,enemy.y));
                                } 
                                
                                if(currentUpgradeLevel<scoreThresholds.length&&score>=scoreThresholds[currentUpgradeLevel]){
                                    player.addUpgradePoint();
                                    currentUpgradeLevel++;
                                    updateUpgradeUI();
                                }
                            } 
                            createExplosion(bullet.x,bullet.y,bulletColor,3,1.5);
                            return false;
                        } 
                        return true;
                    });
                } 
                
                if(enemyAlive){
                    remainingEnemies.push(enemy);
                }
            }); 
            
            enemies=remainingEnemies;
        }
        function drawGameElements(){ctx.save();let shakeX=0;let shakeY=0;if(screenShakeDuration>0){shakeX=(Math.random()-0.5)*screenShakeIntensity;shakeY=(Math.random()-0.5)*screenShakeIntensity;screenShakeDuration--;if(screenShakeDuration<=0)screenShakeIntensity=0;} ctx.translate(shakeX,shakeY); drawBackground();particles.forEach(p=>p.draw());pickups.forEach(p=>p.draw());enemies.forEach(e=>e.draw());bullets.forEach(b=>b.draw());enemyBullets.forEach(eb=>eb.draw());player.draw(); ctx.restore();}

        // --- 난이도 선택 버튼 이벤트 리스너 추가 ---
        easyButton.addEventListener('click', () => handleDifficultyChoice('easy'));
        normalButton.addEventListener('click', () => handleDifficultyChoice('normal'));
        hardButton.addEventListener('click', () => handleDifficultyChoice('hard'));
        
        // 초기 로딩 시 지갑 존재 여부 확인 (완전히 새 버전으로 교체)
        window.addEventListener('load', function() {
            // 페이지 완전 로드 후 2초 지연 후 팬텀 월렛 감지 시도
            setTimeout(async function() {
                console.log("지연 후 팬텀 월렛 감지 시도...");
                
                // 브라우저에 Phantom 지갑이 설치되어 있는지 확인
                const isPhantomInstalled = window.phantom?.solana?.isPhantom || window.solana?.isPhantom;
                if (isPhantomInstalled) {
                    console.log("팬텀 월렛 발견됨! 자동 연결 시도...");
                    const provider = window.phantom?.solana || window.solana;
                    
                    if (provider.isConnected) {
                        // 이미 연결된 상태면 지갑 연결 처리
                        await connectWallet();
                    } else {
                        // 연결되지 않았지만 설치는 되어 있음을 표시
                        showMintStatus("팬텀 월렛이 감지되었습니다. 지갑 연결 버튼을 눌러 연결하세요.", "yellow");
                        walletButton.style.animation = "pulse 2s infinite";
                    }
                } else {
                    console.log("팬텀 월렛을 찾을 수 없습니다.");
                }
            }, 2000);
        });
        
        // --- 게임 시작 ---
        init();

        // 테스트 모드 함수
        async function connectTestMode() {
            console.log("테스트 모드로 진행...");
            walletErrorMessage.textContent = "";
            
            try {
                // 테스트용 더미 지갑 생성
                const testWallet = {
                    publicKey: {
                        toString: () => "TEST1234TEST1234",
                        toBase58: () => "TEST1234TEST1234"
                    },
                    signTransaction: async (tx) => {
                        console.log("테스트 모드: 가상 트랜잭션 서명 요청");
                        try {
                            // 서명 팝업 표시
                            await showSignaturePopup();
                            console.log("테스트 모드: 사용자가 트랜잭션을 승인함");
                            return tx; // 더미 서명
                        } catch (err) {
                            console.log("테스트 모드: 사용자가 트랜잭션을 거부함");
                            throw new Error('User rejected transaction');
                        }
                    },
                    signAllTransactions: async (txs) => {
                        console.log("테스트 모드: 가상 다중 트랜잭션 서명 요청");
                        try {
                            // 서명 팝업 표시
                            await showSignaturePopup();
                            console.log("테스트 모드: 사용자가 다중 트랜잭션을 승인함");
                            return txs; // 더미 서명
                        } catch (err) {
                            console.log("테스트 모드: 사용자가 다중 트랜잭션을 거부함");
                            throw new Error('User rejected transactions');
                        }
                    },
                    connected: true,
                    isConnected: true
                };
                
                wallet = testWallet;
                walletConnected = true;
                currentWalletType = 'test';
                walletButton.textContent = "TEST...1234";
                walletOverlay.style.display = 'none';
                
                // 더미 연결 객체
                connection = {
                    getRecentBlockhash: async () => {
                        console.log("테스트 모드: 가상 블록해시 반환");
                        return { blockhash: "TestBlockhash123" };
                    },
                    sendRawTransaction: async (tx) => {
                        console.log("테스트 모드: 가상 트랜잭션 전송");
                        return "TestSignature123";
                    },
                    confirmTransaction: async (sig) => {
                        console.log("테스트 모드: 가상 트랜잭션 확인");
                        return true;
                    }
                };
                
                showMintStatus("테스트 모드로 진행합니다! 민팅 시뮬레이션 활성화", "green");
            } catch (err) {
                console.error("테스트 모드 설정 오류:", err);
                showMintStatus("테스트 모드 설정 실패", "red");
            }
        }

        // 지갑 어댑터 초기화
        function initWalletAdapters() {
            try {
                console.log("지갑 어댑터 초기화 중...");
                
                // 사용 가능한 어댑터 가져오기 (브라우저 환경에서 사용 가능)
                if (window.solanaWalletAdapterWallets) {
                    // 지갑 어댑터 패키지에서 제공하는 지갑 목록
                    const { PhantomWalletAdapter, SolflareWalletAdapter, SlopeWalletAdapter } = window.solanaWalletAdapterWallets;
                    
                    // 지원할 지갑 어댑터 생성
                    if (PhantomWalletAdapter) walletAdapters.push(new PhantomWalletAdapter());
                    if (SolflareWalletAdapter) walletAdapters.push(new SolflareWalletAdapter());
                    if (SlopeWalletAdapter) walletAdapters.push(new SlopeWalletAdapter());
                    
                    console.log(`${walletAdapters.length}개의 지갑 어댑터가 로드됨`);
                }
                
                // 브라우저에 설치된 지갑 확인
                checkInstalledWallets();
            } catch (err) {
                console.error("지갑 어댑터 초기화 오류:", err);
            }
        }
        
        // 설치된 지갑 확인
        function checkInstalledWallets() {
            console.log("설치된 지갑 확인 중...");
            
            // 팬텀 지갑 확인
            if (window.phantom?.solana || window.solana?.isPhantom) {
                availableWallets.push("phantom");
                walletProviders.phantom = window.phantom?.solana || window.solana;
                connectWalletButton.style.display = "block";
            } else {
                connectWalletButton.style.display = "none";
            }
            
            // 솔플레어 지갑 확인
            if (window.solflare?.isSolflare) {
                availableWallets.push("solflare");
                walletProviders.solflare = window.solflare;
                connectSolflareButton.style.display = "block";
            } else {
                connectSolflareButton.style.display = "none";
            }
            
            // 슬로프 지갑 확인
            if (window.Slope) {
                availableWallets.push("slope");
                connectSlopeButton.style.display = "block";
            } else {
                connectSlopeButton.style.display = "none";
            }
            
            console.log(`사용 가능한 지갑: ${availableWallets.join(", ") || "없음"}`);
            
            // 사용 가능한 지갑이 없으면 어댑터 버튼 숨김
            if (availableWallets.length === 0) {
                walletAdapterButton.style.display = "none";
            }
        }
        
        // 모든 지갑 보기 버튼 클릭시 동작
        function showAllWallets() {
            console.log("모든 지갑 보기");
            
            if (walletAdapters.length === 0) {
                walletErrorMessage.textContent = "지원되는 지갑 어댑터가 없습니다. 지갑을 설치해주세요.";
                return;
            }
            
            // 여기서 모달이나 드롭다운 UI를 표시하여 사용자가 지갑을 선택할 수 있도록 함
            // 예시를 위해 간단히 경고창으로 대체
            let walletNames = walletAdapters.map(adapter => adapter.name).join(", ");
            alert(`지원되는 지갑: ${walletNames}`);
            
            // 실제 구현에서는 여기에 지갑 선택 UI를 만들고 선택한 지갑으로 연결하는 로직 구현
        }

        // 슬로프 지갑 연결 함수
        async function connectSlopeWallet() {
            console.log("슬로프 지갑 연결 시도...");
            walletErrorMessage.textContent = "";
            
            try {
                // 브라우저에 Slope 지갑이 설치되어 있는지 확인
                if (!window.Slope) {
                    console.log("슬로프 지갑이 설치되지 않음");
                    walletErrorMessage.textContent = "슬로프 지갑이 설치되어 있지 않습니다. 설치 후 다시 시도해주세요.";
                    return;
                }
                
                console.log("슬로프 지갑 감지됨, 연결 시도 중...");
                
                try {
                    // 슬로프 어댑터 생성
                    const slope = new window.Slope();
                    
                    // 연결 요청
                    const { msg, data } = await slope.connect();
                    
                    if (msg === 'ok' && data.publicKey) {
                        console.log("연결 성공:", data.publicKey);
                        
                        // 지갑 정보 설정
                        wallet = {
                            publicKey: {
                                toString: () => data.publicKey,
                                toBase58: () => data.publicKey
                            },
                            signTransaction: async (tx) => {
                                const { msg, data: signData } = await slope.signTransaction(tx);
                                if (msg === 'ok') {
                                    return signData.signature;
                                }
                                throw new Error('Slope: 트랜잭션 서명 실패');
                            },
                            connected: true
                        };
                        
                        walletConnected = true;
                        currentWalletType = 'slope';
                        walletButton.textContent = data.publicKey.substr(0, 4) + "..." + data.publicKey.substr(-4);
                        walletOverlay.style.display = 'none';
                        connection = new solanaWeb3.Connection("https://api.devnet.solana.com");
                        showMintStatus("슬로프 지갑 연결 완료!", "green");
                    } else {
                        throw new Error('Slope: 연결 실패');
                    }
                } catch (err) {
                    console.error("연결 과정 오류:", err);
                    walletErrorMessage.textContent = "연결을 거부했거나 오류가 발생했습니다.";
                    showMintStatus("연결을 거부했거나 오류가 발생했습니다", "red");
                }
            } catch (err) {
                console.error("지갑 연결 전체 오류:", err);
                walletErrorMessage.textContent = "지갑 연결에 실패했습니다.";
                showMintStatus("지갑 연결 실패", "red");
            }
        }
        
        // 페이지 로드 시 월렛 어댑터 초기화
        window.addEventListener('load', function() {
            // 월렛 어댑터 초기화
            initWalletAdapters();
            
            // 페이지 완전 로드 후 2초 지연 후 팬텀 월렛 감지 시도
            setTimeout(async function() {
                console.log("지연 후 팬텀 월렛 감지 시도...");
                
                // 브라우저에 Phantom 지갑이 설치되어 있는지 확인
                const isPhantomInstalled = window.phantom?.solana?.isPhantom || window.solana?.isPhantom;
                if (isPhantomInstalled) {
                    console.log("팬텀 월렛 발견됨! 자동 연결 시도...");
                    const provider = window.phantom?.solana || window.solana;
                    
                    if (provider.isConnected) {
                        // 이미 연결된 상태면 지갑 연결 처리
                        await connectWallet();
                    } else {
                        // 연결되지 않았지만 설치는 되어 있음을 표시
                        showMintStatus("팬텀 월렛이 감지되었습니다. 지갑 연결 버튼을 눌러 연결하세요.", "yellow");
                        walletButton.style.animation = "pulse 2s infinite";
                    }
                } else {
                    console.log("팬텀 월렛을 찾을 수 없습니다.");
                }
            }, 2000);
        });

        // 서명 팝업 관련 함수
        function showSignaturePopup() {
            return new Promise((resolve, reject) => {
                signatureResolve = resolve;
                signatureReject = reject;
                signatureOverlay.style.display = 'flex';
                // 게임 일시 정지
                isPaused = true;
            });
        }
        
        function handleSignatureApprove() {
            if (signatureResolve) {
                signatureResolve(true);
                signatureResolve = null;
                signatureReject = null;
                signatureOverlay.style.display = 'none';
                // 게임 재개
                isPaused = false;
            }
        }
        
        function handleSignatureReject() {
            if (signatureReject) {
                signatureReject(new Error('User rejected transaction'));
                signatureResolve = null;
                signatureReject = null;
                signatureOverlay.style.display = 'none';
                // 게임 재개
                isPaused = false;
            }
        }
    </script>
</body>
</html>
